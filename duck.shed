public val duck = object {
    public def Matcher class[T] => () => {
    }
    
    public def equalTo fun[T] => (value: T) => EqualTo[T](value);
    
    def EqualTo class[T] => (value: T) => {
        public def describeSelf fun() => representation(value);
        
        public def matches fun(other: T) => value.equals(other);
        
        public def describeMismatch fun(other: T) =>
            "was ".concat(representation(other));
            
        public def matchesWithDescription fun(other: T) =>
            MatchResult(matches(other), describeMismatch(other))
    }
    
    public def isList fun[T] => (value: List[Matcher[T]]) => IsList[T](value);
    
    def IsList class[T] => (matchers: List[Matcher[T]]) => {
        public def describeSelf fun() => {
            val descriptions = matchers.map(fun(matcher: Matcher[T]) => matcher.describeSelf());
            return "listOf(".concat(join(", ", descriptions)).concat(")");
        }
        
        public def matches fun(other: List[T]) => 
            matchesWithDescription(other).matches()
        
        public def describeMismatch fun(other: List[T]) =>
            matchesWithDescription(other).mismatchDescription();
            
        public def matchesWithDescription fun(other: List[T]) => 
            if (not(matchers.length().equals(other.length()))) {
                val length = other.length().toString();
                val description = "list was of length ".concat(length);
                return MatchResult(false, description);
            } else {
                return matchesElementsWithDescription(other);
            }
            
        def matchesElementsWithDescription fun(other: List[T]) => {
            val mismatches = zip(range(0, matchers.length()), matchers, other)
                .map(pack(execMatcher))
                .foldLeft(emptyList, concat);
            return if (mismatches.isEmpty())
                MatchResult(true, "")
            else
                MatchResult(false, mismatches.head());
        }
        
        def execMatcher fun(index: Double, matcher: Matcher[T], other: T) =>
            if (matcher.matches(other)) 
                none
            else {
                val description = "element at index "
                    .concat(index.toString())
                    .concat(" did not match:")
                    .concat("\n  ")
                    .concat(matcher.describeMismatch(other))
                    .concat("\n  expected ")
                    .concat(matcher.describeSelf());
                return some(description);
            };
    }
    
    def MatchResult class(matches_: Boolean, mismatchDescription_: String) => {
        public def matches fun() => matches_;
        public def mismatchDescription fun() => mismatchDescription_;
    }
    
    def MatchResultWithIndex class(index_: Double, matcher_: Matcher[Nothing], matches_: Boolean, mismatchDescription_: String) => {
        public def index fun() => index_;
        public def matcher fun() => matcher_;
        public def matches fun() => matches_;
        public def mismatchDescription fun() => mismatchDescription_;
    }
};
