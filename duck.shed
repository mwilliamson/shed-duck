import options.some;
import options.none;
import lists;
import sequenceables;
import lazySequenceables;
import strings;

import hat.results;

public val duck = object {
    public def Matcher class[T] => () => {
    }
    
    public def assertThat fun[T] => (value: T, matcher: Matcher[T]) =>
        if matcher.matches(value) then
            results.success()
        else
            results.failure("Expected "
                .concat(matcher.describeSelf())
                .concat("\nbut ")
                .concat(matcher.describeMismatch(value))
            );
    
    public def equalTo fun[T] => (value: T) => EqualTo[T](value);
    
    def EqualTo class[T] => (value: T) => {
        public def describeSelf fun() => representation(value);
        
        public def matches fun(other: T) => value.equals(other);
        
        public def describeMismatch fun(other: T) =>
            "was ".concat(representation(other));
            
        public def matchesWithDescription fun(other: T) =>
            MatchResult(matches(other), describeMismatch(other))
    }
    
    public def isList fun[T] => (value: List[Matcher[T]]) => IsList[T](value);
    
    def IsList class[T] => (matchers: List[Matcher[T]]) => {
        public def describeSelf fun() => do {
            val descriptions = matchers.map(fun(matcher: Matcher[T]) => matcher.describeSelf());
            return "listOf(".concat(strings.join(", ", descriptions)).concat(")");
        }
        
        public def matches fun(other: List[T]) => 
            matchesWithDescription(other).matches()
        
        public def describeMismatch fun(other: List[T]) =>
            matchesWithDescription(other).mismatchDescription();
            
        public def matchesWithDescription fun(other: List[T]) => 
            if not(matchers.length().equals(other.length())) then
                MatchResult(
                    false,
                    "list was of length ".concat(other.length().toString())
                )
            else
                matchesElementsWithDescription(other);
            
        def matchesElementsWithDescription fun(other: List[T]) => do {
            // TODO: remove hack for type parameters
            //val matchResults = lazySequences.map[Tuple[Double, Matcher[T], T], Option[String]](
            val matchResults = lazySequenceables.map[()](
                pack(execMatcher),
                lists.zip(range(0, matchers.length()), matchers, other)
            );
            // Exploit the fact that an option is a sequence
            val mismatches = lazySequenceables.concat[String](matchResults);
            return sequenceables.head[String](mismatches)
                .map[MatchResult](fun(mismatch: String) => MatchResult(false, mismatch))
                .valueOrElse[MatchResult](fun() => MatchResult(true, ""));
        };
        
        def execMatcher fun(index: Double, matcher: Matcher[T], other: T) =>
            if matcher.matches(other) then
                none
            else do {
                val description = "element at index "
                    .concat(index.toString())
                    .concat(" did not match:")
                    .concat("\n  ")
                    .concat(matcher.describeMismatch(other))
                    .concat("\n  expected ")
                    .concat(matcher.describeSelf());
                return some(String)(description);
            };
    }
    
    // TODO: Eurgh, we need to find a better solution to name collisions
    public def MatchResult class(matches_: Boolean, mismatchDescription_: String) => {
        public def matches fun() => matches_;
        public def mismatchDescription fun() => mismatchDescription_;
    }
};
